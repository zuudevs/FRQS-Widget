/**
 * @file layout.cpp
 * @brief Implementation of layout managers.
 * @note Generated by Zuu for a panicking user.
 */

#include "widget/layout.hpp"
#include "widget/widget.hpp" // Wajib ada untuk akses setRect/getRect dan LayoutProps
#include <cmath>
#include <algorithm>

namespace frqs::widget {

// ============================================================================
// STACK LAYOUT IMPLEMENTATION
// ============================================================================

void StackLayout::apply(IWidget* parent) {
    if (!parent) return;

    // Posisi awal mulai dari padding
    int32_t currentX = padding_;
    int32_t currentY = padding_;

    for (const auto& child : parent->getChildren()) {
        if (!child->isVisible()) continue;

        auto childRect = child->getRect();
        
        // Set posisi widget anak
        child->setRect(Rect(currentX, currentY, childRect.w, childRect.h));

        // Geser posisi untuk widget berikutnya
        if (direction_ == Direction::Vertical) {
            currentY += static_cast<int32_t>(childRect.h) + spacing_;
        } else {
            currentX += static_cast<int32_t>(childRect.w) + spacing_;
        }
    }
}

// ============================================================================
// FLEX LAYOUT IMPLEMENTATION (The Complex One)
// ============================================================================

void FlexLayout::apply(IWidget* parent) {
    if (!parent) return;

    Rect<int32_t, uint32_t> parentRect = parent->getRect();
    
    // Tentukan ukuran Main Axis (arah layout) dan Cross Axis (arah tegak lurus)
    uint32_t mainSize = (direction_ == Direction::Row) ? parentRect.w : parentRect.h;
    uint32_t crossSize = (direction_ == Direction::Row) ? parentRect.h : parentRect.w;
    
    // Kurangi padding dari ukuran yang tersedia
    if (mainSize > 2 * padding_) mainSize -= 2 * padding_; else mainSize = 0;
    if (crossSize > 2 * padding_) crossSize -= 2 * padding_; else crossSize = 0;

    // 1. Kumpulkan anak-anak yang visible dan hitung total weight
    std::vector<ChildInfo> activeChildren;
    float totalWeight = 0.0f;
    uint32_t totalFixedSize = 0;
    
    for (const auto& child : parent->getChildren()) {
        if (!child->isVisible()) continue;

        ChildInfo info;
        info.widget = child.get();
        info.typedWidget = dynamic_cast<Widget*>(child.get());
        info.isVisible = true;

        // Ambil LayoutProps (Safe fallback kalau bukan Widget)
        if (info.typedWidget) {
            info.props = info.typedWidget->getLayoutProps();
        } else {
            info.props = LayoutProps{}; // Default props
        }

        // Hitung ukuran basis (sebelum flex grow)
        Rect<int32_t, uint32_t> childRect = child->getRect();
        uint32_t currentMainDim = (direction_ == Direction::Row) ? childRect.w : childRect.h;

        // Pisahkan yang Fixed vs Flexible
        if (info.props.weight > 0.0f) {
            totalWeight += info.props.weight;
            info.allocatedSize = 0; // Nanti dihitung ulang
        } else {
            // Widget dengan weight 0 dianggap ukurannya fixed sesuai size-nya sekarang
            info.allocatedSize = currentMainDim;
            totalFixedSize += currentMainDim;
        }

        activeChildren.push_back(info);
    }

    if (activeChildren.empty()) return;

    // 2. Hitung sisa ruang setelah dikurangi Gap antar widget
    uint32_t totalGap = (static_cast<uint32_t>(activeChildren.size()) > 1) 
                        ? (static_cast<uint32_t>(activeChildren.size()) - 1) * gap_ 
                        : 0;

    int32_t remainingSpace = static_cast<int32_t>(mainSize) - totalFixedSize - totalGap;
    if (remainingSpace < 0) remainingSpace = 0;

    // 3. Distribusikan sisa ruang ke widget yang punya Weight > 0
    if (totalWeight > 0.0f) {
        for (auto& info : activeChildren) {
            if (info.props.weight > 0.0f) {
                float share = info.props.weight / totalWeight;
                info.allocatedSize = static_cast<int32_t>(std::floor(share * remainingSpace));
                
                // Cek Constraints (Min/Max Size)
                // Note: Asumsi member minWidth/minHeight ada di LayoutProps
                // Kalau error, sesuaikan nama membernya dengan struct LayoutProps kamu.
                if (direction_ == Direction::Row) {
                    if (info.props.minWidth > 0 && info.allocatedSize < info.props.minWidth)
                        info.allocatedSize = info.props.minWidth;
                    if (info.props.maxWidth > 0 && info.allocatedSize > info.props.maxWidth)
                        info.allocatedSize = info.props.maxWidth;
                } else {
                    if (info.props.minHeight > 0 && info.allocatedSize < info.props.minHeight)
                        info.allocatedSize = info.props.minHeight;
                     if (info.props.maxHeight > 0 && info.allocatedSize > info.props.maxHeight)
                        info.allocatedSize = info.props.maxHeight;
                }
            }
        }
    }

    // 4. Posisionalkan semua widget (Apply Geometry)
    int32_t currentPos = padding_;
    
    for (auto& info : activeChildren) {
        Rect<int32_t, uint32_t> currentRect = info.widget->getRect();
        
        // Ukuran Cross Axis (lebar kalau Column, tinggi kalau Row)
        int32_t childCrossSize = (direction_ == Direction::Row) ? currentRect.h : currentRect.w;
        int32_t childCrossPos = padding_;

        // Cross Axis Alignment
        // Default: Stretch kalau tidak diset (LayoutProps::Align::Stretch biasanya 0 atau default)
        // Sesuaikan nama Enum 'Align' dan valuenya dengan iwidget.hpp kamu!
        switch (info.props.alignSelf) {
            case LayoutProps::Align::Start:
                childCrossPos = padding_;
                break;
            case LayoutProps::Align::Center:
                childCrossPos = padding_ + (crossSize - childCrossSize) / 2;
                break;
            case LayoutProps::Align::End:
                childCrossPos = padding_ + (crossSize - childCrossSize);
                break;
            case LayoutProps::Align::Stretch:
            default:
                childCrossSize = crossSize; // Full width/height
                childCrossPos = padding_;
                break;
        }
        
        // Final Set Rect
        if (direction_ == Direction::Row) {
            info.widget->setRect(Rect(
                currentPos, 
                childCrossPos, 
                static_cast<uint32_t>(info.allocatedSize), 
                static_cast<uint32_t>(childCrossSize)
            ));
            currentPos += info.allocatedSize + gap_;
        } else {
             info.widget->setRect(Rect(
                childCrossPos, 
                currentPos, 
                static_cast<uint32_t>(childCrossSize), 
                static_cast<uint32_t>(info.allocatedSize)
            ));
            currentPos += info.allocatedSize + gap_;
        }
    }
}

// ============================================================================
// GRID LAYOUT IMPLEMENTATION
// ============================================================================

void GridLayout::apply(IWidget* parent) {
    if (!parent || cols_ == 0 || rows_ == 0) return;

    Rect<int32_t, uint32_t> parentRect = parent->getRect();
    
    // Hitung area yang bisa dipakai
    uint32_t usableW = (parentRect.w > 2 * padding_) ? parentRect.w - 2 * padding_ : 0;
    uint32_t usableH = (parentRect.h > 2 * padding_) ? parentRect.h - 2 * padding_ : 0;
    
    // Kurangi total spacing
    uint32_t totalSpacingW = (cols_ > 1) ? (cols_ - 1) * spacing_ : 0;
    uint32_t totalSpacingH = (rows_ > 1) ? (rows_ - 1) * spacing_ : 0;
    
    if (usableW > totalSpacingW) usableW -= totalSpacingW; else usableW = 0;
    if (usableH > totalSpacingH) usableH -= totalSpacingH; else usableH = 0;

    // Ukuran per cell
    uint32_t cellW = usableW / cols_;
    uint32_t cellH = usableH / rows_;
    
    const auto& children = parent->getChildren();
    size_t index = 0;
    
    // Loop Grid Row x Col
    for (size_t r = 0; r < rows_; ++r) {
        for (size_t c = 0; c < cols_; ++c) {
            // Cari anak visible berikutnya
            while (index < children.size() && !children[index]->isVisible()) {
                index++;
            }
            
            if (index >= children.size()) return; // Habis anak
            
            auto& child = children[index];
            
            int32_t x = padding_ + c * (cellW + spacing_);
            int32_t y = padding_ + r * (cellH + spacing_);
            
            child->setRect(Rect(x, y, cellW, cellH));
            
            index++;
        }
    }
}

} // namespace frqs::widget